<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Fundamental knowledge of Database System</title>
      <link href="/2022/03/12/Fundamental-knowledge-of-Database-System/"/>
      <url>/2022/03/12/Fundamental-knowledge-of-Database-System/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Some C/C++ Explain At an Oral Quiz</title>
      <link href="/2022/03/11/Some-C-C-Explain-At-an-Oral-Quiz/"/>
      <url>/2022/03/11/Some-C-C-Explain-At-an-Oral-Quiz/</url>
      
        <content type="html"><![CDATA[<h1 id="一、虚函数的数据结构及工作原理"><a href="#一、虚函数的数据结构及工作原理" class="headerlink" title="一、虚函数的数据结构及工作原理"></a>一、虚函数的数据结构及工作原理</h1><p>虚函数：用 <a href="https://blog.csdn.net/hackbuteer1/article/details/7558868">virtual</a> 定义的函数。</p><p>虚函数的来源：基于 C++ 可以将子类转换为父类的特性。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CBsaic*parent;</span><br><span class="line">CBasic*p1;</span><br><span class="line">CChildren*child;</span><br><span class="line"></span><br><span class="line">parent = <span class="keyword">new</span> CBasic;</span><br><span class="line">child = <span class="keyword">new</span> CChildren;</span><br><span class="line">p1 = <span class="keyword">new</span> CChildren;</span><br></pre></td></tr></table></figure><p>p1 是 CBsaic 类型的指针，但实例化的对象是 CChildren，若子类和父类有一样的函数，那么 p1 会调用子类函数还是父类函数？基于这个问题，C++ 给出了多态的概念：根据实际对象的类型决定函数调用的具体目标，使用 virtual 关键字对多态进行支持。<strong>被 virtual 声明的函数被重写后具有多态性。</strong></p><p>底层机制：虚函数通过使用<strong>虚函数表</strong>和<strong>虚函数表指针</strong>实现。虚函数表是一个类中虚函数的地址，用于索引类本身和类的虚函数，若子类重写了父类的函数，则会在相应的虚函数表处替换成为子类虚函数的地址。虚函数表指针则存在于每一个对象中，它指向对象所对应 类的虚函数地址。</p><p>构造函数是不是虚函数影响并不大，因为在构造子类之前一定要先构造父类。在<strong>存在继承</strong>并且构造函数需要用来<strong>析构资源</strong>时，构造函数就必须为虚函数。此时，若使用父类指针指向子类，用 delete 构造函数时，只会调用父类，并不会调用子类，这时会照成内存泄漏。</p><h1 id="二、CONST-同-DEFINE-的区别"><a href="#二、CONST-同-DEFINE-的区别" class="headerlink" title="二、CONST 同 DEFINE 的区别"></a>二、CONST 同 DEFINE 的区别</h1><ul><li>CONST 在编译时就会确定他的值；DEFINE 则在预处理时进行替换。</li><li>CONST 是有数据类型的，在编译时需要检查；DEFINE 则没有数据类型，也不需要检查。</li><li>CONST 在静态存储区存储，并且仅存一分；DEFINE 则在代码段区，每一次替换都会进行一次拷贝。</li><li>DEFINE 可以用来防止重复的定义，CONST 则不行。</li></ul><h1 id="三、指针与引用"><a href="#三、指针与引用" class="headerlink" title="三、指针与引用"></a>三、指针与引用</h1><ul><li>指针是一个变量，存储的内容是一个地址；引用是已有对象的别名。</li><li>指针是一个实体，需要分配内存；引用仅是变量的别名，不需要分配。</li><li>指针可以套娃；引用不可以。</li><li>指针和引用的自增运算结果不同。</li><li>指针是间接访问，引用是直接访问。</li><li>指针可以不用初始化，引用则必须初始化。</li></ul><h1 id="四、指针与数据"><a href="#四、指针与数据" class="headerlink" title="四、指针与数据"></a>四、指针与数据</h1><ol><li>数组对应一块内存；指针则指向一块内存。</li><li>数组的地址和空间大小在生命周期中不会变，但内容可能改变；而指针指向的内存大小可以随时改变。</li><li>指针指向常量字符串时，其内容不可更改。</li><li>sizeof() 函数可以计算出数组元素的个数；但不可以计算指针所指的内存大小。</li><li>数组名是常量指针；指针是变量指针。</li><li>对数组引用&amp; 和对指针引用&amp; 意义不同。此时数组名不再当成指向一个元素的常量指针。</li></ol><h1 id="五、不用额外空间实现变量交换"><a href="#五、不用额外空间实现变量交换" class="headerlink" title="五、不用额外空间实现变量交换"></a>五、不用额外空间实现变量交换</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用我最喜欢的异或方式，几乎可以交换任意数据。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Switch_Xor</span><span class="params">(<span class="type">int</span> *p1, <span class="type">int</span> *p2)</span></span>&#123;</span><br><span class="line">*p1 = *p1 ^ *p2;</span><br><span class="line">*p2 = *p1 ^ *p2;</span><br><span class="line">*p1 = *p1 ^ *p2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="六、函数指针与指针函数"><a href="#六、函数指针与指针函数" class="headerlink" title="六、函数指针与指针函数"></a>六、函数指针与指针函数</h1><ul><li>函数指针：函数指针是<strong>指向函数的指针</strong>，是指针变量，和函数名无关，只与参数列表和返回类型有关。</li><li>函数指针：本质是一个函数，返回值是一个指针。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ADD</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">add</span><span class="params">(<span class="type">int</span> *p1, <span class="type">int</span> *p2)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> a = *p1 + *p2;</span><br><span class="line"><span class="type">int</span> *p = &amp;a;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> *p1 = &amp;a;</span><br><span class="line"><span class="type">int</span> *p2 = &amp;b;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个函数指针</span></span><br><span class="line"><span class="comment">// 只能指向有两个int参数，返回值为int的函数</span></span><br><span class="line"><span class="built_in">int</span> (*funp)(<span class="type">int</span>,<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">funp = ADD;</span><br><span class="line">cout &lt;&lt;<span class="string">&quot;函数指针指向ADD函数计算结果：&quot;</span> &lt;&lt;<span class="built_in">funp</span>(a, b) &lt;&lt; endl;</span><br><span class="line">funp = Sub;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;函数指针指向Sub函数计算结果：&quot;</span> &lt;&lt; <span class="built_in">funp</span>(a, b) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;指针函数计算结果：&quot;</span> &lt;&lt;*<span class="built_in">add</span>(p1, p2) &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="七、C-源文件文本到可执行文件的过程"><a href="#七、C-源文件文本到可执行文件的过程" class="headerlink" title="七、C++ 源文件文本到可执行文件的过程"></a>七、C++ 源文件文本到可执行文件的过程</h1><ol><li>预处理：对所有的 DEFINE 进行宏替换；处理所有的条件编译 #IFDEF、#PRAGMA 等；处理 #INCLUDE 指令；删除注释。</li><li>编译：将预处理后的文件进行词法分析、语法分析、语义分析。</li><li>优化性能。</li><li>汇编：将汇编文件转为机器代码。</li><li>链接：包括地址和空间分配，符号决议和重定位。</li></ol><h1 id="八、C-11-新特性"><a href="#八、C-11-新特性" class="headerlink" title="八、C++11 新特性"></a>八、C++11 新特性</h1><ol><li>NULLPTR 代替 NULL，传统 C++ 在识别 NULL 有两种情况。一种是空指针，另一种是当成0。在重载时往往需要把指针当成0去处理。</li><li>类型推导：auto 和 decltype，可以让编译器找出表达式的类型。</li><li>区间迭代：使得 C++ 的 for 语句同 python 一样便捷。</li><li>初始化列表。</li><li>模板增强。</li><li>新增容器：STD::array，STD::forward_list（单链表）</li><li>正则表达式。</li><li>线程支持。</li><li><a href="http://c.biancheng.net/view/7829.html">右值引用</a>。</li></ol><h1 id="九、C-与-C-的区别"><a href="#九、C-与-C-的区别" class="headerlink" title="九、C++ 与 C 的区别"></a>九、C++ 与 C 的区别</h1><ol><li>C 语言只要面向过程设计，核心为数据结构和算法，具有高效性。主要考虑一个过程，对输入处理并得到一个输出。</li><li>C++ 是面向对象的设计，C++ 首先考虑如何构造一个对象模型，让这个 Solution 符合问题，通过对象信息得到输出。</li><li>C++ 增强点：<ol><li>命名空间</li><li>实用性</li><li>register 关键字</li><li>变量监测加强</li><li>STRUCT加强</li></ol></li></ol><h1 id="十、malloc-原理"><a href="#十、malloc-原理" class="headerlink" title="十、malloc 原理"></a>十、malloc 原理</h1><p>函数原型：void* malloc(size_t n) 返回值类型为 void*，为动态分配得到的内存，但大小是确定的，不可以越界。</p><p>malloc 函数的实质是它可以将可用内存块通过链表的方式连接成一个长列表。当 malloc 被调用时，它沿着列表去寻找一个大到可以满足需求的内存。并将内存一分为二，一部分分配给用户，另一部分返回列表内。</p><h1 id="十一、内存泄漏、野指针"><a href="#十一、内存泄漏、野指针" class="headerlink" title="十一、内存泄漏、野指针"></a>十一、内存泄漏、野指针</h1><p>内存泄漏：动态申请的内存空间没有被正常释放，同时也无法被继续使用的情况。</p><p>野指针：指向被释放的内存或者访问受限的指针。</p><p>野指针的起因：</p><ol><li>指针未初始化</li><li>被释放的指针没有被置位NULL</li><li>指针越界操作</li></ol><p>解决内存泄漏的方法：使用<a href="http://c.biancheng.net/view/7909.html">智能指针</a>。</p><h1 id="十二、STATIC"><a href="#十二、STATIC" class="headerlink" title="十二、STATIC"></a>十二、STATIC</h1><h2 id="1、局部静态变量：STATIC-局部变量和普通局部变量的区别？"><a href="#1、局部静态变量：STATIC-局部变量和普通局部变量的区别？" class="headerlink" title="1、局部静态变量：STATIC 局部变量和普通局部变量的区别？"></a>1、局部静态变量：STATIC 局部变量和普通局部变量的区别？</h2><ul><li>STATIC 局部变量只初始化一次，下一次依据上一次的结果值。</li><li>程序的局部变量存在于堆栈中。</li><li>全局变量存在于静态区中。</li><li>动态申请的数据存在于堆中。</li></ul><h2 id="2、全局静态变量：STATIC-全局变量和普通全局变量的区别？"><a href="#2、全局静态变量：STATIC-全局变量和普通全局变量的区别？" class="headerlink" title="2、全局静态变量：STATIC 全局变量和普通全局变量的区别？"></a>2、全局静态变量：STATIC 全局变量和普通全局变量的区别？</h2><ul><li>全局变量用 STATIC 修饰就构成了静态的全局变量。</li><li>全局变量和静态的全局变量都是静态存储方式。</li><li>（非静态）全局变量的作用域是整个源程序，可以跨文件作用。</li><li><strong>静态的全局变量则只在定义该变量的源文件内有效</strong>，只能被该源文件内的函数公用，不可以跨文件。这一特点可以避免在其他源文件中引起错误。</li></ul><h2 id="3、静态成员函数：STATIC-函数与普通函数的区别？"><a href="#3、静态成员函数：STATIC-函数与普通函数的区别？" class="headerlink" title="3、静态成员函数：STATIC 函数与普通函数的区别？"></a>3、静态成员函数：STATIC 函数与普通函数的区别？</h2><ul><li>STATIC 函数和普通函数的作用域不同。</li><li>普通函数默认是 extern 的，可以被别的代码文件调用。</li><li>STATIC 函数只可以在本源码文件中被调用，不可以跨文件调用。基于这一特性，可以避免相同名字函数的冲突。</li><li>STATIC 函数在内存中只有一份，普通函数则在每次调用中维持一份拷贝。</li></ul><h1 id="十三、UNION-与-STRUCT"><a href="#十三、UNION-与-STRUCT" class="headerlink" title="十三、UNION 与 STRUCT"></a>十三、UNION 与 STRUCT</h1><p><a href="https://blog.csdn.net/liguangxianbin/article/details/80510669">UNION 和 STRUCT 有着本质上的区别。</a></p><ol><li>在存储信息时，STRUCT 可以存储多个成员，而 UNION 每个成员会共享一个存储空间，只能存最后同一个成员。</li><li>在任何时刻，UNION 只存放被选中的那个成员，STRUCT 每个成员都在。</li><li>对 UNION 的不同成员复制，将会对其他成员重写。</li></ol><ul><li><p>STRUCT 中所有变量是”共存”的——优点是”有容乃大”，全面；缺点是 STRUCT 内存空间的分配是粗放的，不管用不用，全分配。</p></li><li><p>UNION 中是各变量是”互斥”的——缺点就是不够”包容”；但优点是内存使用更为精细灵活，也节省了内存空间。</p></li></ul><p>STRUCT 会遵循<strong>对齐规则</strong>去存储数据。而 UNION 则按单个成员最大需求去分配，并且每个成员都共享首地址。</p><p>特殊玩法：STRUCT 可以套娃，可以自己套自己，也可以套别人；UNION 则是分配给你一块内存，你随便玩。</p><h1 id="十四、new-与-malloc"><a href="#十四、new-与-malloc" class="headerlink" title="十四、new 与 malloc"></a>十四、new 与 malloc</h1><ol><li>属性：new 是关键字；malloc 是库函数，需要头文件支持。</li><li>参数：new 申请内存无需指定大小，编译器会自行计算；malloc 则需要我们给出。（常用sizeof函数）</li><li>返回类型：new 分配成功返回的是对象类型的指针，和对象严格匹配并不需要类型转换，因此 new 操作是安全的；malloc返回的则是void*。</li><li>分配失败：new 分配失败则会抛出 bad_alloc 异常；malloc 则会返回NULL。</li><li>重载。</li><li>内存区域：new 分配的内存在自由存储区；malloc 则在堆上分配内存。</li></ol><h1 id="十五、C-类型转换"><a href="#十五、C-类型转换" class="headerlink" title="十五、C++ 类型转换"></a>十五、C++ 类型转换</h1><ol><li>static_cast</li><li>dynamic_cast</li><li>const_cast</li><li>reinterpret_cast</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//using namespace std;</span></span><br><span class="line"><span class="comment">//static_cast&lt;typeid&gt;（）其中typeid可以为一般类型，也可以为指针引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数初始化列表</span></span><br><span class="line">    <span class="comment">// http://c.biancheng.net/view/2223.html</span></span><br><span class="line"><span class="built_in">A</span>() :<span class="built_in">i</span>(<span class="number">1</span>), <span class="built_in">j</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">~<span class="built_in">A</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printA</span><span class="params">()</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;call printA() in class A&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printSum</span><span class="params">()</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Sum = &quot;</span> &lt;&lt; i + j &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span>  i, j;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> :<span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">B</span>():<span class="built_in">a</span>(<span class="number">2</span>),<span class="built_in">b</span>(<span class="number">3</span>)&#123;&#125;</span><br><span class="line">~<span class="built_in">B</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printB</span><span class="params">()</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;call printB() in class B&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printSum</span><span class="params">()</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Sum = &quot;</span> &lt;&lt; a + b &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">()</span></span>&#123;</span><br><span class="line">a++;</span><br><span class="line">b++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">double</span> a, b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">B *ptrB = <span class="keyword">new</span> B;          <span class="comment">//创建一个B类型对象。堆区</span></span><br><span class="line">ptrB-&gt;<span class="built_in">printSum</span>();         <span class="comment">//输出和</span></span><br><span class="line"></span><br><span class="line">A *ptrA = <span class="built_in">static_cast</span>&lt;A*&gt;(ptrB);  <span class="comment">//将派生类转化成父类，上行转换</span></span><br><span class="line">ptrA-&gt;<span class="built_in">printA</span>();</span><br><span class="line">ptrA-&gt;<span class="built_in">printSum</span>();</span><br><span class="line"></span><br><span class="line">ptrA = <span class="keyword">new</span> A;                 <span class="comment">//创建一个父类对象</span></span><br><span class="line">ptrB = <span class="built_in">static_cast</span>&lt;B*&gt;(ptrA); <span class="comment">//将父类对象转换成子类对象，下行转换</span></span><br><span class="line">ptrB-&gt;<span class="built_in">printB</span>();</span><br><span class="line">ptrB-&gt;<span class="built_in">printSum</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">B b;                         <span class="comment">//栈上创建一个B类型对象</span></span><br><span class="line">B &amp;rB = b;                   <span class="comment">//对b的引用</span></span><br><span class="line">rB.<span class="built_in">printSum</span>();</span><br><span class="line">A &amp;rA = <span class="built_in">static_cast</span>&lt;A &amp;&gt;(b); <span class="comment">//派生类转换成基类，上行转换</span></span><br><span class="line">rA.<span class="built_in">printA</span>();</span><br><span class="line">rA.<span class="built_in">printSum</span>();</span><br><span class="line"></span><br><span class="line">A a;</span><br><span class="line">A &amp;rA1 = a;</span><br><span class="line">rA1.<span class="built_in">printA</span>();</span><br><span class="line">B &amp;rB1 = <span class="built_in">static_cast</span>&lt;B &amp;&gt;(a); <span class="comment">//将基类转换成派生类，下行转换</span></span><br><span class="line">rB1.<span class="built_in">printB</span>();</span><br><span class="line">rB1.<span class="built_in">printSum</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="十六、面向对象"><a href="#十六、面向对象" class="headerlink" title="十六、面向对象"></a>十六、面向对象</h1><h2 id="1、面向对象"><a href="#1、面向对象" class="headerlink" title="1、面向对象"></a>1、面向对象</h2><p>面向对象把数据和对数据的操作方法放在一起，作为一个相互依靠的整体，称之为对象。对同类对象抽象出共同特效，类中大多数数据只能用本类的方法进行处理。</p><h2 id="2、面向对象三大特性"><a href="#2、面向对象三大特性" class="headerlink" title="2、面向对象三大特性"></a>2、面向对象三大特性</h2><ol><li>封装：将一类事物的属性和行为抽象为一个类，使属性私有化、行为公开化，提高数据隐蔽性，复用性高。</li><li>继承：进一步将属性和行为抽象为一个父类，而每一个子类拥有父类的行为和属性，也有自己的行为和属性。</li><li>多态：<a href="https://www.runoob.com/cplusplus/cpp-polymorphism.html">接口复用。</a>当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。</li></ol><p>这里涉及到 virtual 修饰符。例如父类是形状，有面积方法；父类派生出三角形和四边形两个子类，这两个子类的面积方法不一样，各有各的。这就是多态。</p><h1 id="十七、前置与后置"><a href="#十七、前置与后置" class="headerlink" title="十七、前置与后置"></a>十七、前置与后置</h1><ul><li>前置 ++ 的实现比较高效，自增之后直接返回 *this 指针即可。</li><li>后置 ++ 实现比较麻烦，需要返回自增之前的对象。需要先将对象拷贝一份，然后再自增，最后返回那个拷贝。</li></ul><h1 id="十八、静态库和动态库"><a href="#十八、静态库和动态库" class="headerlink" title="十八、静态库和动态库"></a>十八、静态库和动态库</h1><p>静态库：</p><ol><li>链接时将函数放进可执行的程序中</li><li>可以产生多个副本</li><li>不依赖程序运行</li></ol><p>动态库：</p><ol><li>程序运行后在加载时才会去动态库找函数</li><li>多线程共享</li><li>依赖程序运行</li></ol><h1 id="十九、STRUCT-内存大小的确定"><a href="#十九、STRUCT-内存大小的确定" class="headerlink" title="十九、STRUCT 内存大小的确定"></a>十九、STRUCT 内存大小的确定</h1><p>这一点之前说过了，STRUCT 遵循对齐规则。</p><ul><li>对于 32 位机器，是 4 字节对齐。</li><li>对于 64 位机器，是 8 字节对齐。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上代码的所分配的内存为：4 + 4 + 4 &#x3D; 12 字节</p><h1 id="二十、strlen-与strcpy-——-未完成"><a href="#二十、strlen-与strcpy-——-未完成" class="headerlink" title="二十、strlen()与strcpy()——[未完成]"></a>二十、strlen()与strcpy()——[未完成]</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;test.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//将src字符串复制到desc中</span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">mystrcpy</span><span class="params">(<span class="type">char</span>* desc, <span class="type">const</span> <span class="type">char</span>* src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (desc == <span class="literal">NULL</span> || src == <span class="literal">NULL</span>) <span class="comment">//内存正常判断</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span>* str = desc;</span><br><span class="line">    <span class="keyword">while</span> ( (*str = *src) != <span class="string">&#x27;\0&#x27;</span>)<span class="comment">//‘\0&#x27;字符串结束标志</span></span><br><span class="line">    &#123;</span><br><span class="line">        str++;</span><br><span class="line">        src++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> desc;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">//将src字符串连接到desc中</span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">mystrcat</span><span class="params">(<span class="type">char</span>* desc, <span class="type">const</span> <span class="type">char</span>* src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (desc == <span class="literal">NULL</span> || src == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span>* str = desc;</span><br><span class="line">    <span class="keyword">while</span> (*src++ != <span class="string">&#x27;\0&#x27;</span>); <span class="comment">// 第一步：找出目的字符串的结尾</span></span><br><span class="line">    src--;</span><br><span class="line">    <span class="keyword">while</span> ((*desc++ = *src++) != <span class="string">&#x27;\0&#x27;</span>);<span class="comment">//第二步：将源字符串添加到目的字符串</span></span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">//将src字符串前n个字符复制到desc中</span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">mystrncpy1</span><span class="params">(<span class="type">char</span>* desc, <span class="type">const</span> <span class="type">char</span>* src, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span>* str = desc;</span><br><span class="line">    <span class="comment">//前面应该有个目的内存是否不足判断</span></span><br><span class="line">    <span class="type">int</span> m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (*str != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        str++;</span><br><span class="line">        m++;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (desc == <span class="literal">NULL</span> || src == <span class="literal">NULL</span> || n&gt;m ) <span class="comment">//内存正常判断</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        *str++ = *src++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> desc;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">//比较两个字符串大小</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mystrcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str1, <span class="type">const</span> <span class="type">char</span>* str2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (*str1 &amp;&amp; *str2 &amp;&amp; *str1 == *str2)</span><br><span class="line">    &#123;</span><br><span class="line">        str1++;</span><br><span class="line">        str2++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *str1 - *str2;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">//求出字符串str长度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mystrlength</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (src == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (*src++ != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二十一、memcpy-与memset-——-未完成"><a href="#二十一、memcpy-与memset-——-未完成" class="headerlink" title="二十一、memcpy()与memset()——[未完成]"></a>二十一、memcpy()与memset()——[未完成]</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">memcpy函数用于资源内存（src指向的内存）拷贝到目标内存（desc指向的内存）；拷贝的个数size</span></span><br><span class="line"><span class="comment">用法：：(1)可以拷贝任何类型的对象，因为函数的参数类型是void* ,由于函数拷贝是一个字节一个</span></span><br><span class="line"><span class="comment">      字节拷贝，实际操作是将void*强制转换成了char*，这样才能保证每一次加一个指针</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">//实现，未考虑内存重叠情况</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">memcpy1</span><span class="params">(<span class="type">void</span> * desc, <span class="type">const</span> <span class="type">void</span> * src, <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (desc == <span class="literal">NULL</span> &amp;&amp; src == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* desc1 = (<span class="type">unsigned</span> <span class="type">char</span>*)desc; <span class="comment">//将void*转成unsigned char*类型</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* src1 = (<span class="type">unsigned</span> <span class="type">char</span>*)src;   <span class="comment">//将void*转成unsigned char*类型</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (size--&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *desc1++ = *src1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> desc;  </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">//考虑内存重叠的情况</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">memcpy2</span><span class="params">(<span class="type">void</span>* desc, <span class="type">const</span> <span class="type">void</span> * src, <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(desc == <span class="literal">NULL</span> &amp;&amp; src == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* desc1 = (<span class="type">unsigned</span> <span class="type">char</span>*)desc;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* src1 = (<span class="type">unsigned</span> <span class="type">char</span>*)src;</span><br><span class="line">    <span class="comment">//当内存重叠时，从后往前复制</span></span><br><span class="line">    <span class="keyword">if</span>(desc &gt; src &amp;&amp; desc1 &lt; (src1 + size))<span class="comment">//内存发生重叠</span></span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = size - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            *desc1++ = *src1++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            *desc1++ = *src1++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> desc;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">//memset内部实现memset(void*s,int ch,size_t n)</span></span><br><span class="line"><span class="comment">/*将s所指向的某一块内存中的前n个字节的内容全部设置为ch指定的ASCII值，返回s*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> * <span class="title">memset1</span><span class="params">(<span class="type">void</span> * ptr, <span class="type">int</span> value, <span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span> &amp;&amp; n &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;赋值出现错误&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> *s = (<span class="type">char</span>*)ptr; <span class="comment">//定义一个指针来接str；辅助指针</span></span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        *s++ = (<span class="type">char</span>)value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">//下面就是根据源码而来的memset实现：</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">memset</span><span class="params">(<span class="type">void</span>* dst,<span class="type">int</span> val, <span class="type">size_t</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">void</span>* ret = dst;</span><br><span class="line">    <span class="keyword">while</span>(count--)</span><br><span class="line">    &#123;</span><br><span class="line">        *(<span class="type">char</span>*)dst = (<span class="type">char</span>)val;</span><br><span class="line">        dst = (<span class="type">char</span>*)dst + <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二十二、C-x2F-C-内存管理与分配"><a href="#二十二、C-x2F-C-内存管理与分配" class="headerlink" title="二十二、C&#x2F;C++ 内存管理与分配"></a>二十二、C&#x2F;C++ 内存管理与分配</h1><p>在 C++ 中，内存分为5个区，分别是堆、栈、自由存储器、全局 &#x2F; 静态存储区、常量存储区。</p><h2 id="1、栈"><a href="#1、栈" class="headerlink" title="1、栈"></a>1、栈</h2><p>在执行程序的过程中，局部作用关于出现一些局部变量可以在栈上创建，等脱离该作用域时，创建的内存就会被释放。</p><p>栈是机器系统提供的数据结构，计算机在底层对栈提供了支持：</p><ol><li>有专用寄存器存放栈的地址</li><li>入栈、出栈有专门的指令执行</li></ol><p>因此，栈的效率很高。</p><h2 id="2、堆"><a href="#2、堆" class="headerlink" title="2、堆"></a>2、堆</h2><p>堆是用语程序内存对台分配的，例如 C&#x2F;C++ 中的 new &#x2F; malloc 分配，delete &#x2F; free 释放。</p><p>堆是 C&#x2F;C++ 函数库提供的，其实现机制很复杂。</p><h2 id="3、自由存储区"><a href="#3、自由存储区" class="headerlink" title="3、自由存储区"></a>3、自由存储区</h2><p>自由存储区是 C++ 基于 new 操作符的一个概念，凡是通过 new 申请的内存就是自由存储区。</p><h2 id="4、全局-x2F-静态存储区"><a href="#4、全局-x2F-静态存储区" class="headerlink" title="4、全局 &#x2F; 静态存储区"></a>4、全局 &#x2F; 静态存储区</h2><p>全局 &#x2F; 静态存储区在程序编译期间就已经分配好，在程序整个运行阶段一直存在。</p><h2 id="5、常量存储区"><a href="#5、常量存储区" class="headerlink" title="5、常量存储区"></a>5、常量存储区</h2><p>常量存储区是一块特殊的内存，里面存放的是不允许修改的常量。</p><h1 id="二十三、深拷贝与浅拷贝"><a href="#二十三、深拷贝与浅拷贝" class="headerlink" title="二十三、深拷贝与浅拷贝"></a>二十三、深拷贝与浅拷贝</h1><ul><li>浅拷贝：只拷贝了基本的数据类型，而引用数据类型，复制后也是会发生引用。浅拷贝只是指向被复制的内存地址，如果原来的对象被修改，那么浅拷贝出来的也会被修改。</li><li>深拷贝：在计算机中重新开辟一块新内存，将原来的对象复制过来。常用 new 或者 malloc 等。</li></ul><h1 id="二十四、debug-与-release"><a href="#二十四、debug-与-release" class="headerlink" title="二十四、debug 与 release"></a>二十四、debug 与 release</h1><ul><li>debug：通常被称为调试版本，包含着调试信息，便于程序员调试。</li><li>release：通常成为发布版本，往往是经过各种优化，是的程序在代码大小和运行熟读是最优的，方便用户使用。</li></ul><h1 id="二十五、MAIN-的返回值"><a href="#二十五、MAIN-的返回值" class="headerlink" title="二十五、MAIN 的返回值"></a>二十五、MAIN 的返回值</h1><p>MAIN 函数的返回值用于说明程序的退出状态。</p><p>如果返回0，说明程序正常退出，否则程序是异常退出。</p><p>有的编译器会自动在目标文件中添加 return 0; 语句。</p><h1 id="二十六、C-动态链接库与-C-动态链接库"><a href="#二十六、C-动态链接库与-C-动态链接库" class="headerlink" title="二十六、C++ 动态链接库与 C 动态链接库"></a>二十六、C++ 动态链接库与 C 动态链接库</h1><ul><li>C 调用 C++ 动态链接库：需要用先用 C++ 将库中的类进行 API 封装。</li><li>C++ 调用 C 动态链接库：需要加上 extern C，用 C 编译准则来编译。</li></ul><h1 id="二十七、结构体"><a href="#二十七、结构体" class="headerlink" title="二十七、结构体"></a>二十七、结构体</h1><ul><li>C++中：结构体可以通过重载操作符 “&#x3D;&#x3D;” 来进行结构体的比较，但要注意内存对齐。为了提高 CPU 效率，通常用宏定义来改变内存对齐方式。</li><li>C中：结构体无法比较，且因为内存对齐，空白部分会有垃圾填充造成干扰。</li></ul><h1 id="二十八、拷贝构造函数为什么传递引用——-未完成"><a href="#二十八、拷贝构造函数为什么传递引用——-未完成" class="headerlink" title="二十八、拷贝构造函数为什么传递引用——[未完成]"></a>二十八、拷贝构造函数为什么传递引用——[未完成]</h1><p><a href="https://www.cnblogs.com/chio/archive/2007/09/14/893299.html">原因</a>：参数为引用，不传递值是为了防止拷贝构造函数的无限递归，这会导致栈溢出。这也是编译器的强制要求。</p><hr><p><del><em><strong>未审核部分</strong></em></del></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_test;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> </span><br><span class="line"><span class="comment">//带参数的构造函数</span></span><br><span class="line"><span class="built_in">Example</span>(<span class="type">int</span> x) :<span class="built_in">m_test</span>(x)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;constructor with argument!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//拷贝构造函数</span></span><br><span class="line"><span class="built_in">Example</span>(<span class="type">const</span> Example &amp;test)</span><br><span class="line">&#123;</span><br><span class="line">m_test = test.m_test;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;copy constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//赋值运算符重载</span></span><br><span class="line">Example&amp;  <span class="keyword">operator</span>=(<span class="type">const</span> Example &amp;test)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;assignment operator&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">m_test = test.m_test;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(Example test)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Example <span class="title">aaa</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">Example <span class="title">bbb</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">bbb = aaa;</span><br><span class="line"> </span><br><span class="line">Example ccc = aaa;</span><br><span class="line"><span class="function">Example <span class="title">ddd</span><span class="params">(aaa)</span></span>;</span><br><span class="line">bbb.<span class="built_in">Print</span>(aaa);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">constructor with argument!  <span class="comment">// Example aaa(2);</span></span><br><span class="line">constructor with argument!  <span class="comment">// Example bbb(3);</span></span><br><span class="line">assignment  <span class="keyword">operator</span>        <span class="comment">// bbb = aaa;</span></span><br><span class="line">copy constructor            <span class="comment">// Example ccc = aaa;</span></span><br><span class="line">copy constructor            <span class="comment">// Example ddd(aaa);</span></span><br><span class="line">copy constructor            <span class="comment">// bbb.Print(aaa);</span></span><br></pre></td></tr></table></figure><p>第一二就不解释了</p><p>至于第三个，bbb是已经实例化的对象，不需要构造，因此只会调用&#x3D;运算符重载函数，第四个的ccc还没有实例化，因此要调用拷贝构造函数，构造出ccc，而不是&#x3D;运算符重载函数</p><p>第五个就是拷贝构造函数的应用，</p><p>第六个：实际是将aaa作为参数传递给bbb.Print(Example  ex)，即Example  ex &#x3D; aaa，和第四个一致，所以还是调用拷贝构造函数。</p><p>通过这个例子， 我们来分析一下为什么拷贝构造函数的参数只能使用引用类型。</p><p>看第四个输出： copy constructor                      &#x2F;&#x2F;CExample ccc &#x3D; aaa;</p><p>构造ccc，实质上是ccc.CExample(aaa); 我们假如拷贝构造函数参数不是引用类型的话， 那么将使得 ccc.CExample(aaa)变成aaa传值给ccc.CExample(CExample ex)，即CExample ex &#x3D; aaa，因为 ex 没有被初始化， 所以 CExample ex &#x3D; aaa 继续调用拷贝构造函数，接下来的是构造ex，也就是 ex.CExample(aaa)，必然又会有aaa传给CExample(CExample ex), 即 CExample ex &#x3D; aaa;那么又会触发拷贝构造函数，就这下永远的递归下去。</p><hr><h1 id="二十九、程序崩溃原因"><a href="#二十九、程序崩溃原因" class="headerlink" title="二十九、程序崩溃原因"></a>二十九、程序崩溃原因</h1><ul><li>读取未赋值的变量</li><li>函数栈溢出</li><li>数组越界</li><li>指针目标对象不可用</li></ul><h1 id="三十、C-字符串输入——-未完成"><a href="#三十、C-字符串输入——-未完成" class="headerlink" title="三十、C++ 字符串输入——[未完成]"></a>三十、C++ 字符串输入——[未完成]</h1><ol><li>cin&gt;&gt;</li><li>cin.get()</li><li>cin.getline()</li><li>getline()</li><li>gets()</li><li>getchar()</li></ol><h1 id="三十一、LAMBDA-表达式"><a href="#三十一、LAMBDA-表达式" class="headerlink" title="三十一、LAMBDA 表达式"></a>三十一、LAMBDA 表达式</h1><p>一个 <a href="http://c.biancheng.net/view/7818.html">lambda</a> 表达式表示一个可调用的代码单元，我们可以将其理解为一个未命名的<a href="http://c.biancheng.net/view/199.html">内联函数</a>。</p><p>lambda 和普通函数一样，具有返回类型、参数列表、函数体。但lambda 可以定义在函数内部。其定义如下：</p><p>[capture list 捕获列表](parameter list 参数列表){函数体}</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [](<span class="type">const</span> string &amp;a, <span class="type">const</span> string &amp;b)&#123;<span class="keyword">return</span> a.<span class="built_in">size</span>() &lt; b.<span class="built_in">size</span>()&#125;</span><br></pre></td></tr></table></figure><p>我们可以忽略参数列表和返回类型，但永远包含捕获列表和函数体。</p><p>其中，捕获列表通常为空列表。</p><h1 id="三十二、C-编程优化——-未完成"><a href="#三十二、C-编程优化——-未完成" class="headerlink" title="三十二、C++ 编程优化——[未完成]"></a>三十二、C++ 编程优化——[未完成]</h1><p>\1. 对齐原则。比如64位总线，每次寻址读取8B。编程时注意变量地址，尽量消耗总线最少的寻址次数。堆内存申请时，系统严格按照对齐原则分配，故而使用时候也尽量不要跨寻址边界。</p><p>\2. 需要的时候，可为了效率拷贝代码，虽然增加了代码体积，但这是值得的。尤其是for循环，若次数比较少，拆开亦无妨。</p><p>\3. 位运算中，-1右移，左边补1，故仍为-1；-1左移，右边补0，故不再为-1。</p><p>\4. 每次申请的堆内存，最好初始化，里面是垃圾数据，而并非为空。</p><p>\5. 项目开发中，往往一个引擎对外暴露的是一个纯虚类，而其接口就是这个类的**指针变量。</p><p>\6. 程序逻辑，重在语义。不能为代码的过分简单而减少函数的设计。</p><p>\7. *&amp;表示对指针的引用。</p><p>\8. 类的静态方法不可调用其非静态方法，亦不可调用非静态成员变量。</p><p>\9. 多文件编程时，头文件不可相互包含。</p><p>\10. 头文件里尽量不要使用using namespace std;</p><p>\11. static成员定义要放在cpp文件里面，而不是头文件里。</p><p>\12. 纯虚类尽量不要延续两层以上。</p><p>\13. include引用尽量都放在cpp文件里。</p><p>\14. 子类继承父类，不可在构造函数里初始化父类并未在构造函数里初始化的成员，也就是说，子类构造函数里能初始化的成员，只有自己本身的和父类构造函数里的。</p><p>\15. 项目开发中，对于一些依赖本地环境的参数，要写专门的配置文件，比如服务器地址。</p><p>\16. 头文件里只声明，不定义。在头文件中，全局变量声明，必须加extern修饰；静态成员变量声明放在头文件，定义放在cpp文件，若是普通静态变量，最好声明和定义放在cpp，因为static作用域限于单文件，放在cpp里只对本文件可见，放在头文件会被所有引用该头文件的cpp拷贝一份完全相同的变量。</p><p>\17. linux下，进行文件操作时，文件路径要采用绝对路径（相对路径很多时候会出bug），文件指针要对其返回值作判断，防止空指针。</p><p>\18. debug状态下使用assert是极好的，不过记得发布版本前在#include <cassert>前加上#define NDEBUG，assert语句会被NDEBUG所影响。这里多嘴一句，错误与异常是不同的，异常是不可避免，在发布版本里不可或缺的，故而assert不能用于处理异常。注：在加上#define NDEBUG后，不论是调试还是运行，assert语句都会被直接忽略，故而平时开发时把#define NDEBUG注释掉，发布时再启用它。</p><p>\19. 面向对象编程：可维护，可复用，可扩展，灵活性好。</p><p>\20. 频繁使用的代码里，尽量少使用容器，因为其创建和回收的开销很大。</p><p>\21. 字符串拼接效率：<a href="http://bbs.csdn.net/topics/360000434">经过测试</a>，memcpy效率最高，string类的+&#x3D;效率特别高，足以满足日常所需，而strcat效率很差，append也不快。</p><p>\22. 基类中的虚函数要么实现，要么是纯虚函数（绝对不允许声明不实现，也不纯虚）。</p><p>\23. 在C++的类中，普通成员函数不能作为pthread_create的线程函数，如果要作为pthread_create中的线程函数，必须是static。</p><p>\24. 当多个线程访问同一个类静态方法时，若该方法里只操作栈上数据，则无妨，因为线程的栈是独立的；若该方法操作了非栈上的数据（比如堆、全局变量等），则需要互斥锁。</p><p>\25. 内联函数，定义体要放在头文件，以保证每一个引用该头文件的cpp里都是完全相同的拷贝；inline关键字置于定义前，不必放在声明前；若定义在类内部，可不需要inline关键字。</p><p>\26. vector执行clear时，会自动调用元素（如果是类的话）的析构函数。</p><p>\27. 编程时，对变量（尤其是全局性质的变量或类）命名，要用解释性的，而不能用随意的j1,i1,n,m等名称，容易与库里的变量冲突。</p><p>\28. 定义宏时，尽量多用整数，少用-1，-2之类，容易受uint和int不统一带来的困扰。</p><p>\29. 函数形参采用默认值时，要写在声明里，而不写定义里，这样方便调用其头文件的cpp看得到默认值。</p><p>\31. utf-8 中文编码 三个字节表示一个汉字</p><p>\32. 项目开发时，使用条件编译：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG</span></span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Debugging\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Not debugging\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Running\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发布版本时，注释掉第一行。这种方式要比开大量注释来得方便。</p><p>\33. 关于c字符数组，需要注意一个初始化问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>) <span class="type">char</span> str[<span class="number">10</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">(<span class="number">2</span>) <span class="type">char</span> str[<span class="number">10</span>]=&#123;<span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line">(<span class="number">3</span>) <span class="type">char</span> str[<span class="number">10</span>]; str[<span class="number">0</span>]=<span class="string">&#x27;\0&#x27;</span>;</span><br></pre></td></tr></table></figure><p>前两者的意义在于str的每个元素都初始化为’\0’，第三者仅仅初始化第一个元素。当数组长度很大时，前两者时间开销极大。故而，有些不必要的时候，不要如此初始化。</p><p>\34. 判断一个字符是否为数字：</p><p>头文件：#include &lt;ctype.h&gt;<br>定义函数：int isdigit(int c);<br>函数说明：检查参数 c 是否为阿拉伯数字0 到9。<br>返回值：若参数c 为阿拉伯数字，则返回true，否则返回null(0)。<br>附加说明：此为宏定义，非真正函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="built_in">main</span>()&#123;</span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;123@#FDsP[e?&quot;</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; str[i] != <span class="number">0</span>; i++)</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isdigit</span>(str[i]))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c is an digit character\n&quot;</span>, str[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>\35. 在类里声明静态常量，尤其是数组定义的时候，如static const *str &#x3D; “sdfsssf”, 要在const前加上constexpr修饰，可以在编译器就将“sdfsssf”赋值给str，达到类似宏的效果。</p><p>\36. std::string::find_last_of(“&#x2F;\“) 这里的”&#x2F;\“指的是’&#x2F;‘或’&#39;，在搜索字符时用得到。</p><p>\37. 项目里c字符串传递，多采用首地址+长度的方式，避免0x0存在导致的异常； 线程数要合适，大致为cpu总核数两倍以内为佳，线程间切换会一定程度上消耗程序性能。</p><p>　　有一个陷阱是在c字符串转string类型时，c字符串里如有0，转化时用strlen取长度就会出错。故而，c串表示尽量维护一个len来记录长度，而不是通过结尾0来判别。另外，strlen效率低且不安全，少用。</p><p>\38. 静态函数的实现写在h文件里；尽量把h文件里的函数实现前都加上inline，不论其复杂度，避免被多文件引用而引起重复定义错误。</p><p>\39. 静态成员变量必须在类外进行初始化。如果是复杂类型，比如容器，也要在类外定义，如std::vector&lt;xx *&gt; hj::sm_tr;</p><p>\40. 编程时，一般结构体里的堆内存由内存池管理申请或释放，或者stl里使用这些结构体作为元素时，使用其指针，而不是实例。因为stl里内存申请或释放，会调用其元素的构造和析构，这里会有陷阱。</p><p>\41. 使用set、map时，有一个陷阱，就是[]操作符。当使用这个操作符时，如果[x]里的x并不在set或map里，则stl会自动生成一个x元素，这样使得stl容器内容改变，如果开发者忽略了这点，后果可能无法预期。</p>]]></content>
      
      
      <categories>
          
          <category> 小知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Solved Issue On Conexistence of MySql with v5.7 and v8.0</title>
      <link href="/2022/03/10/Solved-Issue-On-Conexistence-of-MySql-with-v5-7-and-v8-0/"/>
      <url>/2022/03/10/Solved-Issue-On-Conexistence-of-MySql-with-v5-7-and-v8-0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Something About MinGW-w64 On Windows and It&#39;s issue.</title>
      <link href="/2022/03/09/Something-About-MinGW-w64-On-Windows-and-It-s-issue/"/>
      <url>/2022/03/09/Something-About-MinGW-w64-On-Windows-and-It-s-issue/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>get nothing to do with but fall</title>
      <link href="/2022/03/06/get-nothing-to-do-with-but-fall/"/>
      <url>/2022/03/06/get-nothing-to-do-with-but-fall/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Miscellaneous talk About the Way of Setting up BLOG</title>
      <link href="/2022/02/25/Miscellaneous-talk-About-the-Way-of-Setting-up-BLOG/"/>
      <url>/2022/02/25/Miscellaneous-talk-About-the-Way-of-Setting-up-BLOG/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="e01bbd3161203a99c05192b8be492899691ead6b45b6c9265c486e997c9858ce">73efb6a19fe64470c32228f6434b6133506cda7dea18f345879f303750d16d08f23f2e112fb27c0e91df327814629dcbaae557cc3cf60fd901ff4093a5521f706986a582cac74c9cb85815e81802da4f2827dcba73721b1514d6d8614c3aadfd07d85564ccfd6a5874485884b76c60f48f7e6516d854b3ad9c2113a68ddb57aef3486d66a13e5df6fc7b4048c8637de0a14766b9345f3aafccea7c43371b11a26447a69f0b28b7b86c00ab945caa1cd64d62f6dfb38e679a4e260a5b696bafba0be427d5c439f060190a4a4a1c3d30f8439b8de24f4b85d3d4042112efe7040696532cf8c1b06e8a75f041f0582857af4ccf849ed879b6023bb84628fcf2937283d6a181371ffc9ac93975e9e6ef8a3267c570d38e05e57ffc397a7ee61197fb1232160257dd48b874633d8774dad686ca1a85a1ca6e99091325965a2f98c36ce541c19585bf91e5106487290e9df14cd6614ece1f830d99971cb678f166d133bb6543ae74531407b963af6fc7bc84ed50ace6c940755aa16d21c5984edfcf544a4d88c28c22d3a99b676e6bcb98f46c4c4934a67e7bc699e1df9fa2f4da2f8d1a77f57cbece1fc9d5ca34d06a9043e111228a13c42258c6a805526d9f484071d1519e267e9e7e8098a6a4c48adbb744ae6c873b732d7ed929809071c5a82a603de4bbe46b12ae29474844ceb260778afee7cf57fccd1a5c6e4ba11863f7e620e2460d92681aca605de3ea0967f9fcdabf16f2294f7d36bc55f46f2e176298c581ec61059fb0d05e4d882eaa7e8c01a9c1017ad39e96bb3f8cb5c528cacb8f2725732b53959d11f05cd4bc28f8be581eeeccc43ce055ef8a1e48043c74d0efc095eb991b986e46ff0462761f4bed18465596296573cc1713a647bb8cac2dfd2a7f91c2befa15efb1c55727fc2866fef426b544c7bd7b486dfaa3c6dc0c658cb36d6338906ff6b480e406672228b92955c53d66452e38676f48493be6e2ae314b3912291a5405f2ad9ddea36dade7528cb7645a6e3c92474a7572aa844d9e91346246b1c1873d98362618273b3004679ed8e2afbb357c61ce3ae24a9883203a791370f532eee44ea71c9e9b523e13e9553bd67cd1162840f32a23ce37e6889c58451e17fde99bad9b6d0e1a495f3cbcd53e86ef449ea2f5b0435ce2afb6fffbfd46c283fc46458203e3b0203229e19010a187d21ad627f31647a4a924fc3946a02d1f347006b2261931eb8f548f694fbba57b73ae6c52bed76e420e124104d7275e0b6ac38caa503504bf30753a8544447b58b677549b88ebc814a0f63441df1c43c1ee6ba3a6dd8424cedb99dc19f62f7c675b27da17c526a15a48eebc49e0458e6cda3bcc3fa3104881670ebae3119c892233a3de161a53f907857e3e1b9d3a1b1c37189bf8379adfb018a5eb05f5210b84169a85e0dec71970f070246896bbd1c50cb0074c12b3c6a636ce56b30c8805fb39c233fc3872491014ecb62125b1ae62062e1b505e946af89bdd6ce79e90f0376509217740f4cac1ba170752e6061fe02a4ea8e62eba67de8d65ce30e7b7209d136e84ef13517fa7f2afb42f035c631c3073dcd86ce4380493fac0ef88aba0caf520cfaa3f96f9e470ae31c98e2cf0f214359041f7be227ca93db9fa6bf2709214d79931cdb31e7285db0890d63ab34fb44132cfcf76ad0bc08c874aca96740b1b09b04570d12c2d58d5c2b41f66e0392af091a58c213070034974afa5135436aa7e6fb4dd7e78c3416ce508393e993508431038354cd28bac171e3ec1b2d5e2723af9168d051584f1e65668de46866839cff25017555cf5fe7de739fb681f8a40bf3d4799e9c1891006521502fc31648a154e69026a16f01e73f178164059cabc937b07a26b9cab02feb1d22393065811f3fb42bd6ccd11308dd600546a</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">If you are yearned to get access to this essay, please entry cipher. (PS you can try with "Nefelibata")</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BLOG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开题报告</title>
      <link href="/2022/02/25/%E5%BC%80%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
      <url>/2022/02/25/%E5%BC%80%E9%A2%98%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="1-本课题的目的及研究意义"><a href="#1-本课题的目的及研究意义" class="headerlink" title="1. 本课题的目的及研究意义"></a><strong>1.</strong> <strong>本课题的目的及研究意义</strong></h1><p>21世纪以来，随着计算机科学技术的不断提高，互联网技术的日渐成熟，文化交流愈发密切，世界上各类亚文化随之应运而生。二次元便是其中之一，而现在的二次元文化已然逐渐融入了主流，成为流行文化的一员。在当今时代以人物为核心的创作方法，让动漫作品更加便于搭建人物关系和故事框架；而重于对故事元素与人物特征的组合使得故事人物的原创性逐渐丧失。现如今的动漫作品用这样的创作模式，更加偏向于商业化、模式化。对于人物的创作已然不是呕心沥血的“创新”，而是从现有的元素中去结合、进行再创作。这一点正符合GAN算法核心思想。此外，同人创作的作品也会加强这种去中心化的文化特征，通过二次创作，将其不同的符号放入不同的情景进行重组。同时，在互联网时代，网络空间中，一个人所能展现给他人最直接的事物便是他的头像和昵称，也就是一张图片和一段文字。其中信息量最大的毫无疑问是他所选择的头像图片。这一切都不断的越来越深入到我们日常的生活之中，成为我们在网络空间对外展示的最为重要的事物之一。现今，有越来越多的青年人选择动漫人物头像，他们在成长的同时，也需要在网络上突出自我，表达自我。GAN动漫头像生成就可以提供这样的一个功能，可以自己选择自己喜欢的样式，融合不一样的文化符号，最后选择自己需要的头像。同样也可以用在2D、3D游戏建模上，给人更多的灵感。同样的技术，不止步于动漫，只要是一种样式(style)，就可以创造出一个不属于这个世界的，但同时可以以假乱真的、相似、却又独一无二的另一个样式。</p><h1 id="2-本课题的国内外的研究现状以及发展趋势"><a href="#2-本课题的国内外的研究现状以及发展趋势" class="headerlink" title="2. 本课题的国内外的研究现状以及发展趋势"></a><strong>2.</strong> <strong>本课题的国内外的研究现状以及发展趋势</strong></h1><p>生成式对抗性网络(Generative-Adversarial-Networks, GAN)在2014年被Ian Goodfellow等人提出，而这个概念在当时的机器学习、深度学习领域十分新颖，并且掀起了一场新的革命，它则首先被应用在图像方面。例如仅靠机器自己合成一个世界上从未出现过的、难以分辨真假的图像，这种无监督的机器学习性质让GAN功能变的十分强大。因为在当时，机器学习通常需要人工对数据进行标记或者分类，这是一项机械式的、重复性的、十分枯燥乏味的工作。而近年来，随着计算机硬件不断发展、数字图像处理技术的不断提升、GAN架构的不断优化，GAN应用程序变的越发真实。以GAN为中心，可以生成图片、生成文本、将图像的某些性质转移到另一个图像上、增强图片；以人工面孔图像为中心，他可以改变图像人物年龄、改变脸型、外观、肤色、表情、姿势、发型等等。</p><p>生成式对抗网络(Generative-Adversarial-Networks, GAN)正如其名，首先基于神经网络结构网络Networks。其次，这个网络有对抗性Adversarial，这也意味着它会对两个不同的神经网络模型进行训练。我们一般将其分别叫做生成器网络G和鉴别器网络D（或者判别器网络）。而最终通过G、D网络之间的不断优化得到的GAN可以自我生成我们所需要的实例。这些实例看起来和原有的数据分布相似，但却不完全一样。例如生成新的风景照片，其风景的一部分类似于现有的照片数据集，但在细节上仍有一些不同。G网络会学习并且生成新的看似合理的数据样本;D网络则会学着去区分G网络生成的假例子和数据中的真实例子。这两个模型相互学习训练的过程就如同对抗博弈一般。而现有的GAN模型的一般分为两种，①概率模型PBM，②能量模型EBM。但最终在训练之后，生成器G模型就可以按照我们所需要的去自行创建类似的新样本。这种技术可以更好的理解图像空间内在的本质并产生更为精确的结果。这也会使得提升了分辨率之后的图像看起来比原本的图像更加真实、其细节更为精细。</p><p>如今的生成对抗网络，以GAN为基础，已经发展出很多不一样的算法。</p><p>首先是DCGAN，它使用逆卷积层和卷积层替换了GAN的全连接网络，使得网络超参数数量大大减少，同时使用卷积学习局部信息，使得生成的图片质量大幅提升。</p><p>其次便是InfoGAN，相比于普通的GAN，InfoGAN在输入向量处加入了约束c，通过不断的学习与反馈，InfoGAN可以将图片中的一些特征学习出来，比如MNIST手写数字的粗细，倾斜度等；再比如人脸照片是否戴着眼镜等一系列特征。</p><p>再者是CycleGAN，CycleGAN正如其名，其训练过程是一个循环，有着两套判别器和生成器。因而训练时是输入两组图片，CycleGAN则可以自动将某一类图片转换成另一类图片。例如将猫的图片转换成狗，将春天的风景转换成冬天，通过简朴的线条图生成细节丰富的完整图片。</p><p>接下来便是WGAN，其全名是Wasserstein GAN。在Martin Arjovsky提出WGAN之前，GAN算法就存在着训练困难、生成器和判别器容易梯度爆炸或者梯度消失的问题。而WGAN通过使用KL散度和JS散度这两个核心衡量指标，进而引入了Wasserstein距离，通过定义Wasserstein距离的限制可以解决大部分的梯度消失问题。接着通过数学手段，将Wasserstein距离优化改写成计算机可以求解的形式并利用一个WGAN的一个超参数来限制其神经网络。通过跳帧这个参数的数值范围，就可以更容易的落到、并近似等于Wasserstein距离。并在判别器D的学习优化中，进一步逼近W距离，这样可以有效的让生成的分布数据库中的分布尽可能的靠近。通过Wasserstein距离这个核心手段，WGAN自然就解决了GAN训练不稳定的缺陷。也因此提供了一个和生成样本质量高度相关的可靠新指标。在之后的WGAN-GP中，Martin Arjovsky更是在损失函数中添加了梯度惩罚的机制，这使得我们编码WGAN算法更加简易，并再一次证实了WGAN的稳定性。</p><p>再说SAGAN，其的全程是Self-Attention GAN。从名字就可以发现它借鉴了自然语言处理NLP中的Attention机制，提出了属于GAN自己的基于自注意力的机制，SAGAN在此机制上，近一步将图片的质量进行提升，使生成的图片变的更加逼真。</p><p>在SAGAN的基础上，进而发展出了BigGAN。BGAN同样如其名，借用BigData，从大数据，大算力方面的优势，让其生成的图片效果进一步提升。同时也提升了生成图片的分辨率。</p><p>最后来说一下styleGAN，这是英伟达NVIDIA发布的一个基于GAN的开源图像生成方法。这个方法基于NVIDIA之前一个叫proGAN的项目，它们可以控制图像不同的视觉特征。例如姿势、发型、面部形状、面部特征、发型、睁眼&#x2F;闭眼、眼睛头发和皮肤的配色等等。styleGAN更是有”GAN2.0”之称。</p><h1 id="3-本课题的研究内容、研究方法"><a href="#3-本课题的研究内容、研究方法" class="headerlink" title="3. 本课题的研究内容、研究方法"></a><strong>3.</strong> <strong>本课题的研究内容、研究方法</strong></h1><p>本课题，以生成对抗网络GAN思想为基础，通过TensorFlow or PyTorch的深度学习架构，使用Python语言开发model，使用Java进行开发访问GUI控制界面方便人物头像的预览和可视化。其中的核心便是GAN，其原理和框架图如下。</p><p>GAN整个网络由两个部分构成：Generator即生成器G，以及Discriminator，判别器D。其最基础的框架如下：</p><img src="1645886938421.png"  style="zoom: 60%;" /><p>通过不断迭代的训练生成器G和判别器D。从最直观上的理解来说，在不断的训练之后，判别器D的分辨能力会提高；而这同时也会迫使生成器G生成更加逼真的图片。在最理想的情况下，G生成的样本和真实样本基本一致，而D对真假的混合样本的判断是0.5，等同于随机猜想，这就代表已经收敛并且训练完成。而对该模型进一步的优化和超参数调整将在后续工作中进行。其数学描述如下：</p><img src="1645887601861.png"  style="zoom: 60%;" /><p>利用网络查阅大量国内外相关资料、开源项目和文献，利用各网站的数据库资源浏览大量期刊和文献进行深入研究和分析。进入国内外各种深度学习开发者社区和论坛，进行更多交流，获取更多信息和技术。通过不断尝试互联网上现有的方案，并加入自己的理解来相互结合，在不断调整每层GAN的神经网络配置和各种超参数后，我们可以利用网络上公开的GPU计算能力进行迭代，从而获得我们自己的模型。之后，采用模块化结构独立开发各模块的功能，并将站点设置为web模式，以最大限度地减少各模块之间的耦合，并根据各功能模块的实现，构建更加灵活方便的GUI控制界面和UI访问界面。</p><h1 id="4-本课题的研究步骤及预期效果"><a href="#4-本课题的研究步骤及预期效果" class="headerlink" title="4. 本课题的研究步骤及预期效果"></a><strong>4.</strong> <strong>本课题的研究步骤及预期效果</strong></h1><p>2021年12月-2022年2月初            文献搜集与整理、外文翻译、准备开题报告</p><p>2022年2月初-2022年2月末            撰写开题报告</p><p>2022年2月末-2022年3月初            设计研究方案和技术路线，前期工作准备</p><p>2022年3月初-2022年3月底            进行概要设计，详细设计，确定每个模块具体设计概要,完成整体设计，软件编码工作等</p><p>2022年4月初                        测试，完成毕业设计</p><p>2022年4月中                        撰写毕业论文大纲</p><p>2022年4月中-2022年5月中            撰写毕业论文初稿</p><p>2022年5月中-2022年5月20日            教师审阅论文、修改论文</p><h1 id="5-本课题的参考论文及书目"><a href="#5-本课题的参考论文及书目" class="headerlink" title="5. 本课题的参考论文及书目"></a><strong>5.</strong> <strong>本课题的参考论文及书目</strong></h1><p>[1] Bengio, Yoshua, Ian J. Goodfellow, and Aaron Courville. “Deep learning.” An MIT Press book. (2015).<br>[2] LeCun, Yann, Yoshua Bengio, and Geoffrey Hinton. “Deep learning.” Nature 521.7553 (2015): 436-444.<br>[3] Hinton, Geoffrey E., Simon Osindero, and Yee-Whye Teh. “A fast learning algorithm for deep belief nets.” Neural computation 18.7 (2006): 1527-1554.<br>[4] Hinton, Geoffrey E., and Ruslan R. Salakhutdinov. “Reducing the dimensionality of data with neural networks.” Science 313.5786 (2006): 504-507.<br>[5] Krizhevsky, Alex, Ilya Sutskever, and Geoffrey E. Hinton. “Imagenet classification with deep convolutional neural networks.” Advances in neural information processing systems. 2012.<br>[6] Simonyan, Karen, and Andrew Zisserman. “Very deep convolutional networks for large-scale image recognition.” arXiv preprint arXiv:1409.1556 (2014).<br>[7] Szegedy, Christian, et al. “Going deeper with convolutions.” Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition. 2015.<br>[8] Hinton, Geoffrey E., et al. “Improving neural networks by preventing co-adaptation of feature detectors.” arXiv preprint arXiv:1207.0580 (2012).<br>[9] Srivastava, Nitish, et al. “Dropout: a simple way to prevent neural networks from overfitting.” Journal of Machine Learning Research 15.1 (2014): 1929-1958.<br>[10]Ioffe, Sergey, and Christian Szegedy. “Batch normalization: Accelerating deep network training by reducing internal covariate shift.” arXiv preprint arXiv:1502.03167 (2015).<br>[11] Ba, Jimmy Lei, Jamie Ryan Kiros, and Geoffrey E. Hinton. “Layer normalization.” arXiv preprint arXiv:1607.06450 (2016).<br>[12] Courbariaux, Matthieu, et al. “Binarized Neural Networks: Training Neural Networks with Weights and Activations Constrained to+ 1 or−1.”<br>[13] Jaderberg, Max, et al. “Decoupled neural interfaces using synthetic gradients.” arXiv preprint arXiv:1608.05343 (2016).<br>[14] Chen, Tianqi, Ian Goodfellow, and Jonathon Shlens. “Net2net: Accelerating learning via knowledge transfer.” arXiv preprint arXiv:1511.05641 (2015).<br>[15] Wei, Tao, et al. “Network Morphism.” arXiv preprint arXiv:1603.01670 (2016).<br>[16] Graves, Alex. “Generating sequences with recurrent neural networks.” arXiv preprint arXiv:1308.0850 (2013).<br>[17] Vaswani A, Shazeer N, Parmar N, et al. Attention is all you need [C] Advances in Neural Information Processing Systems. 2017: 5998-6008.<br>[18] He K, Zhang X, Ren S, et al. Deep residual learning for image recognition[C] Proceedings of the IEEE conference on computer vision and pattern recognition. 2016: 770-778.<br>[19] Auto-encoding variational Bayes. Kingma, Welling <a href="https://arxiv.org/pdf/1312.6114.pdf">https://arxiv.org/pdf/1312.6114.pdf</a>.<br>[20] Representation learning: a review and new perspectives. Bengio, Courville, Vincent <a href="https://arxiv.org/pdf/1206.5538.pdf">https://arxiv.org/pdf/1206.5538.pdf</a>.<br>[21] Vincent, Pascal; Larochelle, Hugo (2010). “Stacked Denoising Autoencoders: Learning Useful Representations in a Deep Network with a Local Denoising Criterion”. Journal of Machine Learning Research. 11: 3371–3408.<br>[22] Goodfellow, Ian; Pouget-Abadie, Jean; Mirza, Mehdi; Xu, Bing; Warde-Farley, David; Ozair, Sherjil; Courville, Aaron; Bengio, Yoshua (2014). Generative Adversarial Nets (PDF). Proceedings of the International Conference on Neural Information Processing Systems (NIPS 2014). pp. 2672–2680.</p>]]></content>
      
      
      <categories>
          
          <category> 毕设 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Python </tag>
            
            <tag> GAN </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
